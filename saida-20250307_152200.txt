------------------------------------------------------------
RESPOSTA PARA REGRA All objects created by the `Simple Factory` must implement or inherit from a common interface or base class.
------------------------------------------------------------
To verify that all objects created by the `Simple Factory` implement or inherit from a common interface or base class, you can use the Design Wizard library to analyze the relationships between classes. Here is the Java test code using JUnit and Design Wizard to enforce this design rule:

```java
import org.designwizard.DesignWizard;
import org.designwizard.design.ClassNode;
import org.junit.Test;

import java.util.Set;

import static org.junit.Assert.assertTrue;

public class SimpleFactoryTest {

    @Test
    public void testAllProductsImplementCommonInterface() throws Exception {
        DesignWizard dw = new DesignWizard("bin");
        ClassNode productFactory = dw.getClass("com.cnblog.clarck.ProductFactory");
        ClassNode product = dw.getClass("com.cnblog.clarck.Product");

        Set<ClassNode> createdClasses = productFactory.getCalleeClasses();
        for (ClassNode createdClass : createdClasses) {
            assertTrue(createdClass.extendsClass(product) || createdClass.implementsInterface(product));
        }
    }
}
```

This test ensures that all classes created by the `ProductFactory` either extend or implement the `Product` class or interface.



------------------------------------------------------------
RESPOSTA PARA REGRA The client must call the `Simple Factory` to create objects and not use the `new` operator directly.
------------------------------------------------------------
```java
@Test
public void testClientUsesSimpleFactory() throws Exception {
    DesignWizard dw = new DesignWizard("bin");
    ClassNode client = dw.getClass("com.cnblog.clarck.Test");
    ClassNode productFactory = dw.getClass("com.cnblog.clarck.ProductFactory");
    ClassNode productA = dw.getClass("com.cnblog.clarck.ProductA");
    ClassNode productB = dw.getClass("com.cnblog.clarck.ProductB");

    Set<ClassNode> calleeClasses = client.getCalleeClasses();

    assertTrue(calleeClasses.contains(productFactory));
    assertFalse(calleeClasses.contains(productA));
    assertFalse(calleeClasses.contains(productB));
}
```



------------------------------------------------------------
RESPOSTA PARA REGRA The factory class must not store created instances.
------------------------------------------------------------
To ensure that the factory class does not store created instances, you can write a test that verifies the absence of fields or collections that might hold these instances. Here is a Java test case using JUnit and Design Wizard to enforce this rule:

```java
import org.designwizard.DesignWizard;
import org.designwizard.design.ClassNode;
import org.designwizard.design.FieldNode;
import org.junit.Test;

import java.util.Set;

import static org.junit.Assert.assertTrue;

public class FactoryClassTest {

    @Test
    public void testFactoryClassDoesNotStoreInstances() throws Exception {
        DesignWizard dw = new DesignWizard("bin");
        ClassNode factoryClass = dw.getClass("com.cnblog.clarck.ProductFactory");
        Set<FieldNode> fields = factoryClass.getAllFields();

        for (FieldNode field : fields) {
            ClassNode fieldType = field.getReturnType();
            assertTrue("Factory class should not store created instances.",
                    !fieldType.getClassName().equals("com.cnblog.clarck.Product"));
        }
    }
}
```

This test checks that none of the fields in the `ProductFactory` class are of type `Product`, ensuring that the factory class does not store created instances.



------------------------------------------------------------
RESPOSTA PARA REGRA Each product class should be independent and unaware of the factory, ensuring that modifications to the factory do not affect product implementations.
------------------------------------------------------------
```java
import org.designwizard.DesignWizard;
import org.designwizard.design.ClassNode;
import org.junit.Test;

import java.util.Set;

import static org.junit.Assert.assertFalse;

public class ProductFactoryTest {

    @Test
    public void testProductClassesAreIndependentOfFactory() throws Exception {
        DesignWizard dw = new DesignWizard("bin");
        ClassNode productA = dw.getClass("com.cnblog.clarck.ProductA");
        ClassNode productB = dw.getClass("com.cnblog.clarck.ProductB");
        ClassNode productFactory = dw.getClass("com.cnblog.clarck.ProductFactory");

        Set<ClassNode> productACalleeClasses = productA.getCalleeClasses();
        Set<ClassNode> productBCalleeClasses = productB.getCalleeClasses();

        assertFalse(productACalleeClasses.contains(productFactory));
        assertFalse(productBCalleeClasses.contains(productFactory));
    }
}
```



------------------------------------------------------------
RESPOSTA PARA REGRA The factory method should return instances of concrete product classes but expose them only through their common interface or superclass.
------------------------------------------------------------
```java
@Test
public void testFactoryMethodReturnsConcreteProductsThroughInterface() throws Exception {
    DesignWizard dw = new DesignWizard("bin");
    ClassNode productFactory = dw.getClass("com.cnblog.clarck.ProductFactory");
    ClassNode productInterface = dw.getClass("com.cnblog.clarck.Product");

    Set<MethodNode> factoryMethods = productFactory.getAllMethods();
    for (MethodNode method : factoryMethods) {
        if (method.getName().equals("createProduct")) {
            Set<ClassNode> calleeClasses = method.getCalleeClasses();
            for (ClassNode calleeClass : calleeClasses) {
                assertTrue(calleeClass.extendsClass(productInterface));
            }
        }
    }
}
```



