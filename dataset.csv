Texto,Código (Gabarito),Saída 1
"Each strategy must implement the `algorithmInterface` method defined in the abstract class.","@Test
    public void strategyMustImplementExecuteMethod() throws Exception {
            DesignWizard dw = new DesignWizard(""src/com/cnblog/clarck"");
            ClassNode concreteClassA = dw.getClass(""com.cnblog.clarck.ConcreateStrategyA"");
            ClassNode concreteClassB = dw.getClass(""com.cnblog.clarck.ConcreateStrategyB"");
            ClassNode concreteClassC  = dw.getClass(""com.cnblog.clarck.ConcreateStrategyC"");

             MethodNode inhMethodClassA = concreteClassA.getInheritedMethod(""algorithmInterface"");
             MethodNode declMethodClassA = concreteClassA.getDeclaredMethod(""algorithmInterface"");
            assertNotNull(inhMethodClassA);
            assertNotNull(declMethodClassA);

             MethodNode inhMethodClassB = concreteClassB.getInheritedMethod(""algorithmInterface"");
             MethodNode declMethodClassB = concreteClassB.getDeclaredMethod(""algorithmInterface"");
            assertNotNull(inhMethodClassB);
            assertNotNull(declMethodClassB);

             MethodNode inhMethodClassC = concreteClassC.getInheritedMethod(""algorithmInterface"");
             MethodNode declMethodClassC = concreteClassC.getDeclaredMethod(""algorithmInterface"");
            assertNotNull(inhMethodClassC);
            assertNotNull(declMethodClassC);
    }",
"The `Strategy` abstract class was designed to be stateless, so avoid adding state attributes to its implementations.","@Test
    public void testStrategyDoesntHaveFields() throws Exception {
        DesignWizard dw = new DesignWizard(""src/com/cnblog/clarck"");
        ClassNode strategyClass = dw.getClass(""com.cnblog.clarck.Strategy"");
        Set<FieldNode> fields = strategyClass.getAllFields();
        assertTrue(fields.isEmpty());
    }",
"The concrete class needs to extend the `Strategy` abstract class to ensure that the `algorithmInterface` method adheres to the defined contract.","@Test
    public void testConcreteImplementsStrategy() throws Exception {
            DesignWizard dw = new DesignWizard(""src/com/cnblog/clarck"");
            ClassNode classNode = dw.getClass(""com.cnblog.clarck.ConcreateStrategyA"");
            ClassNode classNode2 = dw.getClass(""com.cnblog.clarck.Strategy"");
            assertTrue(classNode.extendsClass(classNode2));
    }",
"Each concrete implementation must encapsulate a single algorithm and be completely independent of the other strategies.","@Test
    public void testIndependentStrategies() throws Exception {
        ClassNode concreateStrategyA = dw.getClass(""com.cnblog.clarck.ConcreateStrategyA"");
        ClassNode concreateStrategyB = dw.getClass(""com.cnblog.clarck.ConcreateStrategyB"");
        ClassNode concreateStrategyC = dw.getClass(""com.cnblog.clarck.ConcreateStrategyC"");

        Set<ClassNode> calleeClassesA = concreateStrategyA.getCalleeClasses();
        Set<ClassNode> calleeClassesB = concreateStrategyB.getCalleeClasses();
        Set<ClassNode> calleeClassesC = concreateStrategyC.getCalleeClasses();

        assertFalse(calleeClassesA.contains(concreateStrategyB));
        assertFalse(calleeClassesA.contains(concreateStrategyC));
        assertFalse(calleeClassesB.contains(concreateStrategyA));
        assertFalse(calleeClassesB.contains(concreateStrategyC));
        assertFalse(calleeClassesC.contains(concreateStrategyA));
        assertFalse(calleeClassesC.contains(concreateStrategyB));

    }",
"The `Strategy` pattern requires the context to use the `Strategy` abstract class, so concrete classes should never be referenced directly.","@Test
    public void testClientOnlyKnowsStrategyInterface() throws Exception {
        DesignWizard dw = new DesignWizard(""src/com/cnblog/clarck"");
        ClassNode concreateStrategyA = dw.getClass(""com.cnblog.clarck.ConcreateStrategyA"");
        ClassNode concreateStrategyB = dw.getClass(""com.cnblog.clarck.ConcreateStrategyB"");
        ClassNode concreateStrategyC = dw.getClass(""com.cnblog.clarck.ConcreateStrategyC"");
        ClassNode strategyClass = dw.getClass(""com.cnblog.clarck.Strategy"");
        ClassNode context = dw.getClass(""com.cnblog.clarck.Context"");
        Set<ClassNode> calleeClasses = context.getCalleeClasses();

        assertTrue(calleeClasses.contains(strategyClass));
        assertFalse(calleeClasses.contains(concreateStrategyA));
        assertFalse(calleeClasses.contains(concreateStrategyB));
        assertFalse(calleeClasses.contains(concreateStrategyC));
    }",
"Only the `Facade` class should directly interact with the subsystems — all other classes must interact exclusively through the `Facade`.","@Test
    public void onlyFacadeInteractsWithSubsystems() throws Exception {
        ClassNode subSys1 = dw.getClass(""com.cnblog.clarck.SubSystemOne"");
        ClassNode subSys2 = dw.getClass(""com.cnblog.clarck.SubSystemTwo"");
        ClassNode subSys3 = dw.getClass(""com.cnblog.clarck.SubSystemThree"");
        ClassNode subSys4 = dw.getClass(""com.cnblog.clarck.SubSystemFour"");

        ClassNode facade = dw.getClass(""com.cnblog.clarck.Facede"");

        Set<ClassNode> callerClasses1 = subSys1.getCallerClasses();
        Set<ClassNode> callerClasses2 = subSys2.getCallerClasses();
        Set<ClassNode> callerClasses3 = subSys3.getCallerClasses();
        Set<ClassNode> callerClasses4 = subSys4.getCallerClasses();

        assertTrue(callerClasses1.size() == 1 && callerClasses1.contains(facade));
        assertTrue(callerClasses2.size() == 1 && callerClasses2.contains(facade));
        assertTrue(callerClasses3.size() == 1 && callerClasses3.contains(facade));
        assertTrue(callerClasses4.size() == 1 && callerClasses4.contains(facade));
    }",
"The `Facade` class should be aware of the internal subsystems, but the subsystems should not depend on or have knowledge of the `Facade`.","@Test
    public void facadeSubsystemsRelations() throws Exception {
        ClassNode subSys1 = dw.getClass(""com.cnblog.clarck.SubSystemOne"");
        ClassNode subSys2 = dw.getClass(""com.cnblog.clarck.SubSystemTwo"");
        ClassNode subSys3 = dw.getClass(""com.cnblog.clarck.SubSystemThree"");
        ClassNode subSys4 = dw.getClass(""com.cnblog.clarck.SubSystemFour"");

        ClassNode facade = dw.getClass(""com.cnblog.clarck.Facede"");

        Set<ClassNode> callerClasses1 = subSys1.getCallerClasses();
        Set<ClassNode> callerClasses2 = subSys2.getCallerClasses();
        Set<ClassNode> callerClasses3 = subSys3.getCallerClasses();
        Set<ClassNode> callerClasses4 = subSys4.getCallerClasses();

        Set<ClassNode> callerClassesFacade = facade.getCallerClasses();

        assertTrue(callerClasses1.contains(facade));
        assertTrue(callerClasses2.contains(facade));
        assertTrue(callerClasses3.contains(facade));
        assertTrue(callerClasses4.contains(facade));

        assertFalse(callerClassesFacade.contains(subSys1));
        assertFalse(callerClassesFacade.contains(subSys2));
        assertFalse(callerClassesFacade.contains(subSys3));
        assertFalse(callerClassesFacade.contains(subSys4));
    }",
"The internal classes that compose the subsystems must not be directly accessible outside the package — this reinforces the use of the `Facade`.","@Test
    public void subsysNotAcessedOutsidePackage() throws Exception {
        ClassNode subSys1 = dw.getClass(""com.cnblog.clarck.SubSystemOne"");
        ClassNode subSys2 = dw.getClass(""com.cnblog.clarck.SubSystemTwo"");
        ClassNode subSys3 = dw.getClass(""com.cnblog.clarck.SubSystemThree"");
        ClassNode subSys4 = dw.getClass(""com.cnblog.clarck.SubSystemFour"");

        PackageNode pkg = dw.getPackage(""com.cnblog.clarck"");

        Set<PackageNode> callerPackages1 = subSys1.getCallerPackages();
        Set<PackageNode> callerPackages2 = subSys2.getCallerPackages();
        Set<PackageNode> callerPackages3 = subSys3.getCallerPackages();
        Set<PackageNode> callerPackages4 = subSys4.getCallerPackages();

        assertTrue(callerPackages1.size() == 1 && callerPackages1.contains(pkg));
        assertTrue(callerPackages2.size() == 1 && callerPackages2.contains(pkg));
        assertTrue(callerPackages3.size() == 1 && callerPackages3.contains(pkg));
        assertTrue(callerPackages4.size() == 1 && callerPackages4.contains(pkg));

    }",
"All objects created by the `Simple Factory` must implement or inherit from a common interface or base class.","@Test
    public void objectsCreatedMustExtendsBaseClass() throws Exception {
         ClassNode productFactory = dw.getClass(""com.cnblog.clarck.ProductFactory"");

        MethodNode createProductMethod = concreteClassA.getDeclaredMethod(""createProduct"");
        
        ClassNode createdProduct = createProductMethod.getReturnType();

        ClassNode productA = dw.getClass(""com.cnblog.clarck.ProductA"");
        ClassNode productA = dw.getClass(""com.cnblog.clarck.ProductA"");

        assertTrue(productA.extendsClass(createdProduct));
        assertTrue(productB.extendsClass(createdProduct));


    }",
"The client must call the `Simple Factory` to create objects and not use the `new` operator directly.","@Test
    public void clientShouldNotCallNewOperator() throws Exception {
        ClassNode client = dw.getClass(""com.cnblog.clarck.Client"");

        MethodNode createProduct = dw
                .getMethod(""com.cnblog.clarck.ProductFactory.createProduct(com.cnblog.clarck.ProductType)"");

        MethodNode constructorA = dw.getMethod(""com.cnblog.clarck.ProductA.<init>()"");
        MethodNode constructorB = dw.getMethod(""com.cnblog.clarck.ProductB.<init>()"");

        Set<MethodNode> calleeMethods = client.getCalleeMethods();

        assertTrue(calleeMethods.contains(createProduct));

        assertFalse(calleeMethods.contains(constructorA));
        assertFalse(calleeMethods.contains(constructorB));

    }",
"Every component, whether it’s a leaf or a composite, must extend the Component abstract class to ensure consistent behavior.","    @Test
    public void leafAndCompositeMustImplementComponent() throws Exception {
        ClassNode component = dw.getClass(""com.cnblog.clarck.Component"");

        ClassNode composite = dw.getClass(""com.cnblog.clarck.Composite"");
        ClassNode leaf = dw.getClass(""com.cnblog.clarck.Leaf"");

        assertTrue(composite.extendsClass(component));
        assertTrue(leaf.extendsClass(component));
    }",
"Make sure the leaf nodes don’t have any children — their methods should operate as if they are the end of the hierarchy.","    @Test(expected = InexistentEntityException.class)
    public void leafMustNotHaveChildren() throws Exception {
        ClassNode leaf = dw.getClass(""com.cnblog.clarck.Leaf"");

        leaf.getField(""children"");
    }",
"The client shouldn’t need to know whether it’s working with a leaf or a composite — that’s the whole point of the pattern.","    @Test
    public void clientShouldntKnowLeafOrComposite() throws Exception {
        ClassNode client = dw.getClass(""com.cnblog.clarck.Client"");

        ClassNode component = dw.getClass(""com.cnblog.clarck.Component"");

        ClassNode composite = dw.getClass(""com.cnblog.clarck.Composite"");
        ClassNode leaf = dw.getClass(""com.cnblog.clarck.Leaf"");

        Set<ClassNode> calleeClassesClient = client.getCalleeClasses();

        assertFalse(calleeClassesClient.contains(composite));
        assertFalse(calleeClassesClient.contains(leaf));
    }",
"Instead of exposing direct references to child nodes, the composite should provide methods to manage children, like add, remove, or getChild.","    @Test(expected = InexistentEntityException.class)
    public void compositeChildrenMustBePrivate() throws Exception {
        ClassNode composite = dw.getClass(""com.cnblog.clarck.Composite"");

        FieldNode children = composite.getField(""children"");
        assertTrue(children.getModifiers().contains(Modifier.PRIVATE));
    }",
"The Adapter class must extend the target class so the client can interact with it seamlessly.","    @Test
    public void adapterImplementsTarget() throws Exception {
        ClassNode target = dw.getClass(""com.cnblog.clarck.Target"");
        ClassNode adapter = dw.getClass(""com.cnblog.clarck.Adapter"");

        assertTrue(adapter.extendsClass(target));
    }",
"The client should only know about the target class, not the adaptee or the Adapter implementation.","    @Test
    public void clienOnlyKnowsTarget() throws Exception {
        ClassNode adaptee = dw.getClass(""com.cnblog.clarck.Adaptee"");
        ClassNode adapter = dw.getClass(""com.cnblog.clarck.Adapter"");
        ClassNode target = dw.getClass(""com.cnblog.clarck.Target"");
        ClassNode client = dw.getClass(""com.cnblog.clarck.Client"");

        Set<ClassNode> calleeClasses = client.getCalleeClasses();

        assertFalse(calleeClasses.contains(adaptee));
        assertFalse(calleeClasses.contains(adapter));
        assertTrue(calleeClasses.contains(target));
    }",
"Use composition instead of inheritance in the Adapter to wrap the adaptee, keeping the two classes loosely coupled.","    @Test
    public void useComposition() throws Exception {
        ClassNode adaptee = dw.getClass(""com.cnblog.clarck.Adaptee"");
        ClassNode adapter = dw.getClass(""com.cnblog.clarck.Adapter"");

        Set<ClassNode> calleeClasses = adapter.getCalleeClasses();

        assertFalse(adapter.extendsClass(adaptee));
        assertTrue(calleeClasses.contains(adaptee));
    }",
"The Adapter should expose only the methods defined in the target class, even if the adaptee has additional functionality.","    @Test
    public void adapterShouldOnlyExposeTargetMethods() throws Exception {
        ClassNode adapter = dw.getClass(""com.cnblog.clarck.Adapter"");

        Set<MethodNode> publicMethods = adapter.getMethods(Modifier.PUBLIC);

        for (method in publicMethods) {
                 assertNotNull(adapter.getInheritedMethod(method.getShortName());
        }
    }",
"Each Concrete Builder should extend the Builder abstract class and provide specific implementations for constructing parts of the product.","    @Test
    public void concreteImplementsBuilder() throws Exception {
        ClassNode concBuilder1 = dw.getClass(""com.cnblog.clarck.ConcrateBuilder1"");
        ClassNode concBuilder2 = dw.getClass(""com.cnblog.clarck.ConcrateBuilder2"");

        ClassNode builder = dw.getClass(""com.cnblog.clarck.Builder"");

        assertTrue(concBuilder1.extendsClass(builder));
        assertTrue(concBuilder2.extendsClass(builder));
    }",
"The product class should be independent of the Builder — the Builder is responsible for assembling the product, but the product doesn’t know about the Builder.","    @Test
    public void productIndependentOfBuilder() throws Exception {
        ClassNode product = dw.getClass(""com.cnblog.clarck.Product"");
        ClassNode builder = dw.getClass(""com.cnblog.clarck.Builder"");

        Set<ClassNode> calleeProduct = product.getCalleeClasses();

        assertFalse(calleeProduct.contains(builder));
    }",
"The client should interact only with the Director or the Builder class and never directly with the Concrete Builder.","    @Test
    public void clientInteractions() throws Exception {
        ClassNode client = dw.getClass(""com.cnblog.clarck.Client"");
        ClassNode builder = dw.getClass(""com.cnblog.clarck.Builder"");
        ClassNode director = dw.getClass(""com.cnblog.clarck.Director"");
        ClassNode concBuilder1 = dw.getClass(""com.cnblog.clarck.ConcrateBuilder1"");
        ClassNode concBuilder2 = dw.getClass(""com.cnblog.clarck.ConcrateBuilder2"");

        Set<ClassNode> clientCallees = client.getCalleeClasses();

        assertFalse(clientCallees.contains(concBuilder1));
        assertFalse(clientCallees.contains(concBuilder2));
        assertTrue(clientCallees.contains(director));
        assertTrue(clientCallees.contains(builder));
    }",
"Avoid tightly coupling the Director to a specific Builder — it should only know about the Builder class.","    @Test
    public void directorOnlyKnowsBuilderInterface() throws Exception {
        ClassNode builder = dw.getClass(""com.cnblog.clarck.Builder"");
        ClassNode director = dw.getClass(""com.cnblog.clarck.Director"");
        ClassNode concBuilder1 = dw.getClass(""com.cnblog.clarck.ConcrateBuilder1"");
        ClassNode concBuilder2 = dw.getClass(""com.cnblog.clarck.ConcrateBuilder2"");

        Set<ClassNode> directorCallees = director.getCalleeClasses();

        assertFalse(directorCallees.contains(concBuilder1));
        assertFalse(directorCallees.contains(concBuilder2));
        assertTrue(directorCallees.contains(builder));
    }",