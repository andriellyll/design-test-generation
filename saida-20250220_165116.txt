------------------------------------------------------------
RESPOSTA PARA REGRA Each strategy must implement the `algorithmInterface` method defined in the abstract class.
------------------------------------------------------------
```java
@Test
public void testEachStrategyImplementsAlgorithmInterface() throws Exception {
    DesignWizard dw = new DesignWizard("src/com/cnblog/clarck");
    ClassNode abstractStrategy = dw.getClass("com.cnblog.clarck.AbstractStrategy");
    MethodNode algorithmInterface = abstractStrategy.getDeclaredMethod("algorithmInterface()");

    Set<ClassNode> strategies = dw.getClass("com.cnblog.clarck.Strategy").getSubClasses();

    for (ClassNode strategy : strategies) {
        MethodNode implementedMethod = strategy.getDeclaredMethod("algorithmInterface()");
        assertNotNull(implementedMethod);
        assertTrue(implementedMethod.equals(algorithmInterface));
    }
}
```



------------------------------------------------------------
RESPOSTA PARA REGRA The `Strategy` abstract class was designed to be stateless, so avoid adding state attributes to its implementations.
------------------------------------------------------------
```java
@Test
public void testStrategyImplementationsAreStateless() throws Exception {
    Design design = new Design();
    design.addClassExtractedFromCode("com.example.Strategy");
    design.addClassExtractedFromCode("com.example.ConcreteStrategyA");
    design.addClassExtractedFromCode("com.example.ConcreteStrategyB");
    design.resolveDependences();

    ClassNode strategyClass = design.getClass("com.example.Strategy");
    ClassNode concreteStrategyA = design.getClass("com.example.ConcreteStrategyA");
    ClassNode concreteStrategyB = design.getClass("com.example.ConcreteStrategyB");

    assertTrue(strategyClass.isAbstract());
    assertFalse(concreteStrategyA.isAbstract());
    assertFalse(concreteStrategyB.isAbstract());

    Set<FieldNode> fieldsA = concreteStrategyA.getFields();
    Set<FieldNode> fieldsB = concreteStrategyB.getFields();

    for (FieldNode field : fieldsA) {
        assertFalse(field.containsModifiers(Modifier.STATIC));
    }

    for (FieldNode field : fieldsB) {
        assertFalse(field.containsModifiers(Modifier.STATIC));
    }
}
```



------------------------------------------------------------
RESPOSTA PARA REGRA The concrete class needs to extend the `Strategy` abstract class to ensure that the `algorithmInterface` method adheres to the defined contract.
------------------------------------------------------------
```java
@Test
public void testConcreteClassExtendsStrategy() throws Exception {
    DesignWizard dw = new DesignWizard("src/com/cnblog/clarck");
    ClassNode concreteStrategyA = dw.getClass("com.cnblog.clarck.ConcreateStrategyA");
    ClassNode strategyClass = dw.getClass("com.cnblog.clarck.Strategy");

    assertTrue(concreteStrategyA.extendsClass(strategyClass));
}
```



------------------------------------------------------------
RESPOSTA PARA REGRA Each concrete implementation must encapsulate a single algorithm and be completely independent of the other strategies.
------------------------------------------------------------
```java
@Test
public void testEachConcreteImplementationEncapsulatesSingleAlgorithm() throws Exception {
    DesignWizard dw = new DesignWizard("src/com/cnblog/clarck");
    ClassNode strategyA = dw.getClass("com.cnblog.clarck.ConcreateStrategyA");
    ClassNode strategyB = dw.getClass("com.cnblog.clarck.ConcreateStrategyB");
    ClassNode strategyC = dw.getClass("com.cnblog.clarck.ConcreateStrategyC");

    Set<MethodNode> methodsA = strategyA.getAllMethods();
    Set<MethodNode> methodsB = strategyB.getAllMethods();
    Set<MethodNode> methodsC = strategyC.getAllMethods();

    // Check that each strategy has a unique set of methods
    assertFalse(methodsA.isEmpty());
    assertFalse(methodsB.isEmpty());
    assertFalse(methodsC.isEmpty());

    // Check that methods in one strategy are not present in another
    for (MethodNode methodA : methodsA) {
        assertFalse(methodsB.contains(methodA));
        assertFalse(methodsC.contains(methodA));
    }

    for (MethodNode methodB : methodsB) {
        assertFalse(methodsA.contains(methodB));
        assertFalse(methodsC.contains(methodB));
    }

    for (MethodNode methodC : methodsC) {
        assertFalse(methodsA.contains(methodC));
        assertFalse(methodsB.contains(methodC));
    }
}
```



------------------------------------------------------------
RESPOSTA PARA REGRA The `Strategy` pattern requires the context to use the `Strategy` abstract class, so concrete classes should never be referenced directly.
------------------------------------------------------------
```java
@Test
public void testContextOnlyKnowsStrategyAbstractClass() throws Exception {
    DesignWizard dw = new DesignWizard("src/com/cnblog/clarck");
    ClassNode concreteStrategyA = dw.getClass("com.cnblog.clarck.ConcreteStrategyA");
    ClassNode concreteStrategyB = dw.getClass("com.cnblog.clarck.ConcreteStrategyB");
    ClassNode concreteStrategyC = dw.getClass("com.cnblog.clarck.ConcreteStrategyC");
    ClassNode strategyAbstractClass = dw.getClass("com.cnblog.clarck.Strategy");
    ClassNode context = dw.getClass("com.cnblog.clarck.Context");
    Set<ClassNode> calleeClasses = context.getCalleeClasses();

    assertTrue(calleeClasses.contains(strategyAbstractClass));
    assertFalse(calleeClasses.contains(concreteStrategyA));
    assertFalse(calleeClasses.contains(concreteStrategyB));
    assertFalse(calleeClasses.contains(concreteStrategyC));
}
```



------------------------------------------------------------
RESPOSTA PARA REGRA Only the `Facade` class should directly interact with the subsystems — all other classes must interact exclusively through the `Facade`.
------------------------------------------------------------
```java
@Test
public void testFacadeInteractsWithSubsystems() throws Exception {
    DesignWizard dw = new DesignWizard("src/com/cnblog/clarck");
    PackageNode facadePackage = dw.getPackage("com.cnblog.clarck.facade");
    PackageNode subsystemPackage = dw.getPackage("com.cnblog.clarck.subsystem");

    Set<ClassNode> facadeClasses = facadePackage.getAllClasses();
    Set<ClassNode> subsystemClasses = subsystemPackage.getAllClasses();

    for (ClassNode facadeClass : facadeClasses) {
        Set<ClassNode> calleeClasses = facadeClass.getCalleeClasses();
        for (ClassNode calleeClass : calleeClasses) {
            assertTrue(subsystemClasses.contains(calleeClass) || facadeClasses.contains(calleeClass));
        }
    }

    for (ClassNode subsystemClass : subsystemClasses) {
        Set<ClassNode> callerClasses = subsystemClass.getCallerClasses();
        for (ClassNode callerClass : callerClasses) {
            assertTrue(facadeClasses.contains(callerClass));
        }
    }
}
```



------------------------------------------------------------
RESPOSTA PARA REGRA The `Facade` class should be aware of the internal subsystems, but the subsystems should not depend on or have knowledge of the `Facade`.
------------------------------------------------------------
```java
@Test
public void testFacadeKnowsSubsystemsButNotViceVersa() throws Exception {
    DesignWizard dw = new DesignWizard("src/com/cnblog/clarck");
    ClassNode facade = dw.getClass("com.cnblog.clarck.Facade");
    ClassNode subsystemA = dw.getClass("com.cnblog.clarck.SubsystemA");
    ClassNode subsystemB = dw.getClass("com.cnblog.clarck.SubsystemB");
    ClassNode subsystemC = dw.getClass("com.cnblog.clarck.SubsystemC");

    Set<ClassNode> facadeCalleeClasses = facade.getCalleeClasses();
    Set<ClassNode> subsystemACallerClasses = subsystemA.getCallerClasses();
    Set<ClassNode> subsystemBCallerClasses = subsystemB.getCallerClasses();
    Set<ClassNode> subsystemCCallerClasses = subsystemC.getCallerClasses();

    assertTrue(facadeCalleeClasses.contains(subsystemA));
    assertTrue(facadeCalleeClasses.contains(subsystemB));
    assertTrue(facadeCalleeClasses.contains(subsystemC));

    assertFalse(subsystemACallerClasses.contains(facade));
    assertFalse(subsystemBCallerClasses.contains(facade));
    assertFalse(subsystemCCallerClasses.contains(facade));
}
```



------------------------------------------------------------
RESPOSTA PARA REGRA The internal classes that compose the subsystems must not be directly accessible outside the package — this reinforces the use of the `Facade`.
------------------------------------------------------------
```java
@Test
public void testInternalClassesNotAccessibleOutsidePackage() throws Exception {
    DesignWizard dw = new DesignWizard("src/com/cnblog/clarck");
    PackageNode subsystemPackage = dw.getPackage("com.cnblog.clarck.subsystem");
    Set<ClassNode> internalClasses = subsystemPackage.getAllClasses();
    Set<ClassNode> externalClasses = new HashSet<>();

    for (ClassNode internalClass : internalClasses) {
        Set<ClassNode> callerClasses = internalClass.getCallerClasses();
        for (ClassNode callerClass : callerClasses) {
            if (!callerClass.getPackage().equals(subsystemPackage)) {
                externalClasses.add(callerClass);
            }
        }
    }

    assertTrue(externalClasses.isEmpty());
}
```



------------------------------------------------------------
RESPOSTA PARA REGRA All objects created by the `Simple Factory` must implement or inherit from a common interface or base class.
------------------------------------------------------------
```java
@Test
public void testAllObjectsCreatedBySimpleFactoryImplementCommonInterface() throws Exception {
    DesignWizard dw = new DesignWizard("/home/user/application/classes");
    ClassNode factoryClass = dw.getClass("com.example.SimpleFactory");
    ClassNode commonInterface = dw.getClass("com.example.CommonInterface");

    Set<MethodNode> factoryMethods = factoryClass.getAllMethods();
    for (MethodNode method : factoryMethods) {
        if (method.getReturnType() != null) {
            ClassNode returnType = method.getReturnType();
            assertTrue(returnType.implementsInterface(commonInterface) || returnType.extendsClass(commonInterface));
        }
    }
}
```



------------------------------------------------------------
RESPOSTA PARA REGRA The client must call the `Simple Factory` to create objects and not use the `new` operator directly.
------------------------------------------------------------
```java
@Test
public void testClientUsesSimpleFactory() throws Exception {
    DesignWizard dw = new DesignWizard("src/com/cnblog/clarck");
    ClassNode client = dw.getClass("com.cnblog.clarck.Client");
    ClassNode simpleFactory = dw.getClass("com.cnblog.clarck.SimpleFactory");
    Set<ClassNode> calleeClasses = client.getCalleeClasses();

    assertTrue(calleeClasses.contains(simpleFactory));
}
```



------------------------------------------------------------
RESPOSTA PARA REGRA Every component, whether it’s a leaf or a composite, must extend the Component abstract class to ensure consistent behavior.
------------------------------------------------------------
```java
@Test
public void testAllComponentsExtendComponent() throws Exception {
    Design design = new Design();
    design.addClassExtractedFromCode("com.example.Component");
    design.addClassExtractedFromCode("com.example.Leaf");
    design.addClassExtractedFromCode("com.example.Composite");

    ClassNode componentClass = design.getClass("com.example.Component");
    ClassNode leafClass = design.getClass("com.example.Leaf");
    ClassNode compositeClass = design.getClass("com.example.Composite");

    assertTrue(leafClass.extendsClass(componentClass));
    assertTrue(compositeClass.extendsClass(componentClass));
}
```



------------------------------------------------------------
RESPOSTA PARA REGRA Make sure the leaf nodes don’t have any children — their methods should operate as if they are the end of the hierarchy.
------------------------------------------------------------
```java
@Test
public void testLeafNodesHaveNoChildren() throws Exception {
    DesignWizard dw = new DesignWizard("src/com/cnblog/clarck");
    ClassNode leafNodeA = dw.getClass("com.cnblog.clarck.LeafNodeA");
    ClassNode leafNodeB = dw.getClass("com.cnblog.clarck.LeafNodeB");
    ClassNode leafNodeC = dw.getClass("com.cnblog.clarck.LeafNodeC");

    Set<MethodNode> methodsA = leafNodeA.getAllMethods();
    Set<MethodNode> methodsB = leafNodeB.getAllMethods();
    Set<MethodNode> methodsC = leafNodeC.getAllMethods();

    for (MethodNode method : methodsA) {
        assertTrue(method.getCalleeMethods().isEmpty());
    }

    for (MethodNode method : methodsB) {
        assertTrue(method.getCalleeMethods().isEmpty());
    }

    for (MethodNode method : methodsC) {
        assertTrue(method.getCalleeMethods().isEmpty());
    }
}
```



------------------------------------------------------------
RESPOSTA PARA REGRA The client shouldn’t need to know whether it’s working with a leaf or a composite — that’s the whole point of the pattern.
------------------------------------------------------------
To enforce this design rule, you can create a test that verifies whether the client code interacts with the composite structure through the common interface, ensuring that it does not directly reference the leaf or composite classes. This test will use the Design Wizard library to analyze the code and check the relationships between classes. Here is the Java test code using JUnit and Design Wizard:

```java
import org.designwizard.DesignWizard;
import org.designwizard.design.ClassNode;
import org.designwizard.design.MethodNode;
import org.junit.Test;

import java.util.Set;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

public class CompositePatternTest {

    @Test
    public void testClientOnlyKnowsComponentInterface() throws Exception {
        DesignWizard dw = new DesignWizard("src/com/example");
        ClassNode client = dw.getClass("com.example.Client");
        ClassNode component = dw.getClass("com.example.Component");
        ClassNode leaf = dw.getClass("com.example.Leaf");
        ClassNode composite = dw.getClass("com.example.Composite");

        Set<ClassNode> calleeClasses = client.getCalleeClasses();

        assertTrue(calleeClasses.contains(component));
        assertFalse(calleeClasses.contains(leaf));
        assertFalse(calleeClasses.contains(composite));
    }
}
```

This test ensures that the `Client` class only interacts with the `Component` interface and does not directly reference the `Leaf` or `Composite` classes.



------------------------------------------------------------
RESPOSTA PARA REGRA Instead of exposing direct references to child nodes, the composite should provide methods to manage children, like add, remove, or getChild.
------------------------------------------------------------
```java
@Test
public void testCompositeManagesChildren() throws Exception {
    DesignWizard dw = new DesignWizard("src/com/cnblog/clarck");
    ClassNode composite = dw.getClass("com.cnblog.clarck.Composite");
    MethodNode addChildMethod = composite.getMethod("addChild(Child)");
    MethodNode removeChildMethod = composite.getMethod("removeChild(Child)");
    MethodNode getChildMethod = composite.getMethod("getChild(int)");

    assertNotNull(addChildMethod);
    assertNotNull(removeChildMethod);
    assertNotNull(getChildMethod);
}
```



------------------------------------------------------------
RESPOSTA PARA REGRA The Adapter class must extend the target class so the client can interact with it seamlessly.
------------------------------------------------------------
```java
@Test
public void testAdapterExtendsTarget() throws Exception {
    DesignWizard dw = new DesignWizard("src/com/cnblog/clarck");
    ClassNode adapter = dw.getClass("com.cnblog.clarck.Adapter");
    ClassNode target = dw.getClass("com.cnblog.clarck.Target");

    assertTrue(adapter.extendsClass(target));
}
```



------------------------------------------------------------
RESPOSTA PARA REGRA The client should only know about the target class, not the adaptee or the Adapter implementation.
------------------------------------------------------------
```java
@Test
public void testClientOnlyKnowsTargetClass() throws Exception {
    DesignWizard dw = new DesignWizard("src/com/cnblog/clarck");
    ClassNode client = dw.getClass("com.cnblog.clarck.Client");
    ClassNode target = dw.getClass("com.cnblog.clarck.Target");
    ClassNode adaptee = dw.getClass("com.cnblog.clarck.Adaptee");
    ClassNode adapter = dw.getClass("com.cnblog.clarck.Adapter");
    Set<ClassNode> calleeClasses = client.getCalleeClasses();

    assertTrue(calleeClasses.contains(target));
    assertFalse(calleeClasses.contains(adaptee));
    assertFalse(calleeClasses.contains(adapter));
}
```



------------------------------------------------------------
RESPOSTA PARA REGRA Use composition instead of inheritance in the Adapter to wrap the adaptee, keeping the two classes loosely coupled.
------------------------------------------------------------
```java
@Test
public void testAdapterUsesCompositionInsteadOfInheritance() throws Exception {
    DesignWizard dw = new DesignWizard("src/com/cnblog/clarck");
    ClassNode adapter = dw.getClass("com.cnblog.clarck.Adapter");
    ClassNode adaptee = dw.getClass("com.cnblog.clarck.Adaptee");

    Set<ClassNode> superClasses = adapter.getSuperClasses();

    assertFalse(superClasses.contains(adaptee), "Adapter should not inherit from Adaptee");

    Set<FieldNode> fields = adapter.getDeclaredFields();
    boolean hasAdapteeField = fields.stream().anyMatch(field -> field.getType().equals(adaptee));

    assertTrue(hasAdapteeField, "Adapter should have a field of type Adaptee");
}
```



------------------------------------------------------------
RESPOSTA PARA REGRA The Adapter should expose only the methods defined in the target class, even if the adaptee has additional functionality.
------------------------------------------------------------
```java
@Test
public void testAdapterExposesOnlyTargetMethods() throws Exception {
    DesignWizard dw = new DesignWizard("src/com/cnblog/clarck");
    ClassNode adapter = dw.getClass("com.cnblog.clarck.Adapter");
    ClassNode target = dw.getClass("com.cnblog.clarck.Target");
    ClassNode adaptee = dw.getClass("com.cnblog.clarck.Adaptee");

    Set<MethodNode> adapterMethods = adapter.getDeclaredMethods();
    Set<MethodNode> targetMethods = target.getDeclaredMethods();
    Set<MethodNode> adapteeMethods = adaptee.getDeclaredMethods();

    for (MethodNode method : adapterMethods) {
        assertTrue(targetMethods.contains(method) || adapteeMethods.contains(method));
    }

    for (MethodNode method : targetMethods) {
        assertTrue(adapterMethods.contains(method));
    }

    for (MethodNode method : adapteeMethods) {
        assertFalse(adapterMethods.contains(method));
    }
}
```



------------------------------------------------------------
RESPOSTA PARA REGRA Each Concrete Builder should extend the Builder abstract class and provide specific implementations for constructing parts of the product.
------------------------------------------------------------
```java
@Test
public void testConcreteBuildersExtendBuilder() throws Exception {
    DesignWizard dw = new DesignWizard("src/com/cnblog/clarck");
    ClassNode builderClass = dw.getClass("com.cnblog.clarck.Builder");
    ClassNode concreteBuilderA = dw.getClass("com.cnblog.clarck.ConcreteBuilderA");
    ClassNode concreteBuilderB = dw.getClass("com.cnblog.clarck.ConcreteBuilderB");

    assertTrue(concreteBuilderA.extendsClass(builderClass));
    assertTrue(concreteBuilderB.extendsClass(builderClass));
}
```



------------------------------------------------------------
RESPOSTA PARA REGRA The product class should be independent of the Builder — the Builder is responsible for assembling the product, but the product doesn’t know about the Builder.
------------------------------------------------------------
```java
@Test
public void testProductIndependenceFromBuilder() throws Exception {
    DesignWizard dw = new DesignWizard("src/com/cnblog/clarck");
    ClassNode productClass = dw.getClass("com.cnblog.clarck.Product");
    ClassNode builderClass = dw.getClass("com.cnblog.clarck.Builder");

    Set<ClassNode> calleeClasses = productClass.getCalleeClasses();

    assertFalse(calleeClasses.contains(builderClass));
}
```



------------------------------------------------------------
RESPOSTA PARA REGRA The client should interact only with the Director or the Builder class and never directly with the Concrete Builder.
------------------------------------------------------------
```java
@Test
public void testClientOnlyInteractsWithDirectorOrBuilder() throws Exception {
    DesignWizard dw = new DesignWizard("src/com/cnblog/clarck");
    ClassNode client = dw.getClass("com.cnblog.clarck.Client");
    ClassNode director = dw.getClass("com.cnblog.clarck.Director");
    ClassNode builder = dw.getClass("com.cnblog.clarck.Builder");
    ClassNode concreteBuilder = dw.getClass("com.cnblog.clarck.ConcreteBuilder");

    Set<ClassNode> calleeClasses = client.getCalleeClasses();

    assertTrue(calleeClasses.contains(director) || calleeClasses.contains(builder));
    assertFalse(calleeClasses.contains(concreteBuilder));
}
```



------------------------------------------------------------
RESPOSTA PARA REGRA Avoid tightly coupling the Director to a specific Builder — it should only know about the Builder class.
------------------------------------------------------------
```java
@Test
public void testDirectorOnlyKnowsBuilderClass() throws Exception {
    DesignWizard dw = new DesignWizard("src/com/cnblog/clarck");
    ClassNode director = dw.getClass("com.cnblog.clarck.Director");
    ClassNode concreteBuilderA = dw.getClass("com.cnblog.clarck.ConcreteBuilderA");
    ClassNode concreteBuilderB = dw.getClass("com.cnblog.clarck.ConcreteBuilderB");
    ClassNode builderClass = dw.getClass("com.cnblog.clarck.Builder");
    Set<ClassNode> calleeClasses = director.getCalleeClasses();

    assertTrue(calleeClasses.contains(builderClass));
    assertFalse(calleeClasses.contains(concreteBuilderA));
    assertFalse(calleeClasses.contains(concreteBuilderB));
}
```



